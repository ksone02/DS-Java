선택정렬 -> 최솟값을 선택하여 정렬 안된 부분의 가장 작은원소와 교환하는 알고리즘
삽입정렬 -> 가장 왼쪽 원소를 정렬된 부분에 삽입하는 방식의 정렬 알고리즘
-> 수행시간
-> 이미 정렬된 된 경우 O(N)
-> 역으로 정렬된 경우O(N^2)
worst case 원소 교환 횟수: O(N^2)

쉘 정렬
전처리과정, h-정렬(h-sort)
네칸만큼

j >= h && isless(a[i, a[j-hj)

힙정렬
1.  최대힙(Max heap)
2. downheap
총 수행시간 = O(N logN)

downheap(a, i ,heapsize);
oosnheap< i, heps

수행시간

졸아서 내용 누락

13주차 2차시---

학습내용 -> 뒤로 갈 수록 성능이 좋은 것
즉 퀵 정렬이 젤 좋음.

선택정렬은 젤 작은 값을 젤 앞으로 이동.
입력에 민감하지 않음 -> 항상 O(N^2)

--여기까지 복습

합병정렬
-> 재귀알고리즘을 기본으로

Merge sort는 N인 입력을 1/2N 크기를 갖는 입력 2개로 분할, 재귀, 2개의
정렬된 부분을 합병하는 정렬알고리즘
분할정복(Divide-and-Conquer)알고리즘:

수행시간
어떤 입력에도 O(NlogN)시간 보장

T(N) = O(NlogN)

퀵 정렬
맨 왼쪽 원소(피벗, Pivot)
재귀적으로
O(NlogN)

최악의경우 O(N^2)는 어쩔 수 없는듯

