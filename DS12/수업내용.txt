hash
해쉬테이블의 요소는 꽉차면 안됨 널널하게 유지해주자
꽉차있다 -> 넓혀줌 (재해시)

O(logN)보다 좋은 성능 -> O(1)밖에 없다. ==> 해시테이블의 삽입/삭제 수행시간 --> O(1)
수행시간과상관없이삭제와삽입이되게만들어진자료구조가해시테이블이다.

고유한 값 -> 키(중복되지 않는 것)을 활용
키값에 함수를 적용시켜 바꾸어 인덱스로 쓰자. -> Hashing 해싱

선형조사의 문제점: 1차 군집화(Primary Clustering)
- 키들이 빈틈없이 뭉쳐지는 현상
- 해시성능저하

개방주소방식(Open Addressing)
해시테이블 전체를 기준 -> 충돌된 키를 일정한 규칙에 따라 저장(Empty 공간을 찾아서)

선형조사
(h(key) + j) % M j = 0, 1, 2, ...

이차조사
(h(key) + j^2) % M

이차조사의 문제점: 이차 군집화(Secondary Clustering)

이중해싱
[] = (h(key) + j * d(key)) mod M
--> 모든 군집화 문제 해결 --> 가장 좋은 해싱 방법

개방주소방식 --> 군집화문제(1,2,3) --> 이중 해싱으로 해결


폐쇄주소방식(Closed Addressing)
키에 대한 해시값에 대응하는 곳에만 키를 저장
대표적인방법: 체이닝(Chaining)
ex) Linked List --> Chain 처럼 연결되어있다

굳이 empty 값을 찾지 않고 한 key 값에 나란히 저장

재해시
[0]적재율(Load Factor)
> 적재율 a = 저장된 키 수 N / 테이블 크기 M

[1]재해시(Rehash)
> OFFLINE 에 저장 후 수행
a > 0.75 -> 3/4가 되면 * 2, a < 0.25 -> 1/4 되면 * 1/2

해시방법의 성능 비교 및 응용
[0]O(1)

대표적인 해싱방법의 성능비교
수식 중요 X, 비교해서 보자